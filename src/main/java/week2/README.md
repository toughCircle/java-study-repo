# Java 기본 개념 정리 2

## 1. 문자열 처리
### 1. String
- 불변한 특성을 가진 문자열 객체
- 문자열 연산 시 매번 새로운 String 객체를 생성하므로 메모리 사용과 성능에 부담이 발생할 수 있음.
- 주로 변경이 거의 없는 문자열 데이터를 다룰 때 사용.

### 2. StringBuilder
- 가변한 문자열을 처리하는 클래스
- 동기화를 지원하지 않으므로 단일 스레드 환경에서 빠른 성능을 제공.
- 빈번한 문자열 덧붙이기, 수정 작업에 유리.

### 3. StringBuffer
- `StringBuilder`와 유사하지만 스레드 안전.
- 내부적으로 동기화를 지원하므로 멀티스레드 환경에서 안전하게 사용 가능.
- 하지만 동기화로 인한 성능 부담이 있을 수 있음.

## 2. 예외 처리
### 2-1. 기본 예외처리 구조: try-catch-finally
- `try` 블록에 예외 발생 가능성이 있는 코드를 배치.
- `catch` 블록에서 발생한 예외를 잡아 처리
- `finally` 블록은 예외 발생 여부와 상관없이 항상 실행되는 블록, 주로 자원 해제를 위해 활용.

### 2-2. Checked 예외와 Unchecked 예외의 차이점
### Checked 예외
- 컴파일 시점에 반드시 예외 처리가 요구되는 예외.
- 예) IOException, SQLException
- 이러한 예외는 메서드 선언부에 throws로 명시하거나 try-catch로 처리해야 함.

### Unchecked 예외
- RuntimeException 계열 예외이며, 컴파일러가 예외 처리를 강제하지 않음.
- 예) NullPointException, ArithmeticException
- 일반적으로 프로그래머의 실수로 발생하는 예외를 의미, 필요에 따라 적절한 방어 코드를 추가.

### 2-3. 사용자 정의 예외 생성 및 활용
- 사용자 정의 예외는 Exception 혹은 RuntimeException을 상속받아 만들 수 있음.
- 특정 상황에 맞는 의미 있는 예외를 던져 가독성과 유지보수성을 높일 수 있음.

## 3. 제네릭의 필요성과 활용법
### 제네릭이란?
- 제네릭은 클래스나 메서드를 선언할 때 타입을 파라미터화하는 기능.
- 다양한 타입을 처리하면서도 컴파일 시점에 타입 안정성 확보 가능.
- 타입을 한정 짓거나 유연하게 받을 수 있어, 코드 재사용성과 안정성을 높임.

### 왜 사용해야 하는가?
1. 타입 안정성
   - 컴파일 시점에 잘못된 타입 사용을 걸러낼 수 있어 런타임 에러를 줄임.
2. 가독성과 유지보수성 향상
   - 명시적인 타입 선언을 통해 코드를 읽고 이해하기 쉬워짐.
3. 코드 재사용성 극대화
   - 한 번 작성한 클래스나 메서드를 다양한 타입과 함께 재활용 가능.

### 와일드카드(Wildcards)

와일드카드는 ?를 사용하며, 제네릭 타입 파라미터에 들어올 수 있는 타입을 좀 더 유연하게 정의.

- ? extends T
  - 상위 클래스 T를 상속한 하위 타입들을 받아들일 수 있음.
  - ? extends T는 주로 읽기 전용으로 사용되는 경우가 많음. (Producer 역할)

- ? super T
  - 하위 타입 T의 상위 타입들을 받아들일 수 있음.
  - ? super T는 주로 값을 넣어주는(Consumer 역할) 상황에서 사용.