# Java 기본 개념 정리 2

## 1. 문자열 처리
### 1. String
- 불변한 특성을 가진 문자열 객체
- 문자열 연산 시 매번 새로운 String 객체를 생성하므로 메모리 사용과 성능에 부담이 발생할 수 있음.
- 주로 변경이 거의 없는 문자열 데이터를 다룰 때 사용.

### 2. StringBuilder
- 가변한 문자열을 처리하는 클래스
- 동기화를 지원하지 않으므로 단일 스레드 환경에서 빠른 성능을 제공.
- 빈번한 문자열 덧붙이기, 수정 작업에 유리.

### 3. StringBuffer
- `StringBuilder`와 유사하지만 스레드 안전.
- 내부적으로 동기화를 지원하므로 멀티스레드 환경에서 안전하게 사용 가능.
- 하지만 동기화로 인한 성능 부담이 있을 수 있음.

## 2. 예외 처리
### 2-1. 기본 예외처리 구조: try-catch-finally
- `try` 블록에 예외 발생 가능성이 있는 코드를 배치.
- `catch` 블록에서 발생한 예외를 잡아 처리
- `finally` 블록은 예외 발생 여부와 상관없이 항상 실행되는 블록, 주로 자원 해제를 위해 활용.

### 2-2. Checked 예외와 Unchecked 예외의 차이점
### Checked 예외
- 컴파일 시점에 반드시 예외 처리가 요구되는 예외.
- 예) IOException, SQLException
- 이러한 예외는 메서드 선언부에 throws로 명시하거나 try-catch로 처리해야 함.

### Unchecked 예외
- RuntimeException 계열 예외이며, 컴파일러가 예외 처리를 강제하지 않음.
- 예) NullPointException, ArithmeticException
- 일반적으로 프로그래머의 실수로 발생하는 예외를 의미, 필요에 따라 적절한 방어 코드를 추가.

### 2-3. 사용자 정의 예외 생성 및 활용
- 사용자 정의 예외는 Exception 혹은 RuntimeException을 상속받아 만들 수 있음.
- 특정 상황에 맞는 의미 있는 예외를 던져 가독성과 유지보수성을 높일 수 있음.

## 3. 제네릭의 필요성과 활용법
### 제네릭이란?
- 제네릭은 클래스나 메서드를 선언할 때 타입을 파라미터화하는 기능.
- 다양한 타입을 처리하면서도 컴파일 시점에 타입 안정성 확보 가능.
- 타입을 한정 짓거나 유연하게 받을 수 있어, 코드 재사용성과 안정성을 높임.

### 왜 사용해야 하는가?
1. 타입 안정성
   - 컴파일 시점에 잘못된 타입 사용을 걸러낼 수 있어 런타임 에러를 줄임.
2. 가독성과 유지보수성 향상
   - 명시적인 타입 선언을 통해 코드를 읽고 이해하기 쉬워짐.
3. 코드 재사용성 극대화
   - 한 번 작성한 클래스나 메서드를 다양한 타입과 함께 재활용 가능.

### 와일드카드(Wildcards)

와일드카드는 ?를 사용하며, 제네릭 타입 파라미터에 들어올 수 있는 타입을 좀 더 유연하게 정의.

- ? extends T
  - 상위 클래스 T를 상속한 하위 타입들을 받아들일 수 있음.
  - ? extends T는 주로 읽기 전용으로 사용되는 경우가 많음. (Producer 역할)

- ? super T
  - 하위 타입 T의 상위 타입들을 받아들일 수 있음.
  - ? super T는 주로 값을 넣어주는(Consumer 역할) 상황에서 사용.

## 4. 람다 표현식(Lambda Expression)과 함수형 인터페이스

### 람다 표현식
- 자바에서 람다 표현식은 익명 함수를 간결한 문법으로 표현하는 방식.
- 메서드를 하나의 식으로 작성해 사용할 수 있어 간단하고 유지보수 편리.

### 함수형 인터페이스(Functional Interface)
- 단 하나의 추상 메서드를 가지는 인터페이스.
- 예: `java.lang.Runnable`(추상 메서드: `run`), `java.util.Comparator`(추상 메서드: `compare`).
- 함수형 인터페이스를 대상으로 람다 표현식을 사용하면, 익명 클래스를 대체할 수 있음.

## 5. 스트림(Stream) API

### 스트림 API
- 자바 8부터 지원하는 데이터 처리용 API.
- 컬렉션, 배열 등의 데이터를 한 번에 처리하기 위한 간결하고 효율적인 방법을 제공.
- 내부 반복(Internal Iteration)을 사용하므로 코드 가독성이 뛰어나고, 병렬 처리(Parallel Stream)도 간단하게 적용 가능.

### 스트림의 중간 연산과 최종 연산
- 중간 연산(Intermediate Operation): 스트림을 반환하는 연산. 여러 개 체인 형태로 연결해 사용 가능. 예: filter, map, sorted, distinct, limit, skip 등.
- 최종 연산(Terminal Operation): 스트림을 소모(consume)하며 결과를 반환하는 연산. 예: collect, reduce, forEach, count 등.

## 6. 어노테이션(Annotation)
### 개념
- 메타데이터의 한 형태로 컴파일러나 런타임 프로세스가 코드를 해석할 때 힌트를 제공.
- 코드 문서화나 빌드/런타임 시 특정 처리가 가능하도록 도움.

### 자주 사용하는 기본 어노테이션
* `@Override`
  - 부모 클래스(또는 인터페이스)에서 상속하거나 구현받은 메서드를 재정의할 때 사용.
  - 정확한 오타 검출과 가독성 측면에서 유용.
* `@Deprecated`
  - 앞으로 사용하지 말아야 할 메서드/클래스 등에 붙여 경고를 나타냄.
  - 대체 API나 리팩터링 유도를 위해 활용.
* `@SuppressWarnings`
  - 컴파일러 경고를 무시할 때 사용.
  - 필요한 경우에만 신중하게 적용해야 함.