# Java 기본 개념 정리

## 1. Java의 주요 특징
   - **플랫폼 독립성**: JVM을 통해 OS에 상관없이 실행 가능.
   - **객체지향 언어**: 캡슐화, 상속, 다형성, 추상화 지원.
   - **멀티스레드 지원**: 병렬 작업을 쉽게 구현.
   - **강타입 언어**: 변수의 데이터 타입을 명확히 지정.
   - **자동 메모리 관리**: Garbage Collector를 통해 메모리 해제 관리.

## 2. Java 실행 과정과 JVM 역할

### 2-1. Java 실행 과정
- **소스 코드 작성**: `.java` 파일 작성.
- **컴파일**: `javac` 명령어로 `.class` 바이트코드 생성.
- **JVM 실행**: 바이트코드를 JVM이 OS와 호환되도록 실행.

### 2-2. JVM의 역할
- **플랫폼 독립성 제공**: 운영 체제와 독립적으로 Java 프로그램을 실행할 수 있도록 지원.
- **바이트코드 실행**: `.class` 파일을 읽고, 실행 엔진을 통해 명령어를 기계어로 변환.
- **메모리 관리**: Heap, Stack 등의 메모리 영역을 관리하고, Garbage Collector를 통해 메모리 해제 처리.
- **프로그램 보안 관리**: Class Loader와 Bytecode Verifier를 통해 프로그램의 무결성 및 보안성을 확인.

## 3. JDK와 JRE
1. **JDK (Java Development Kit)**: 개발 도구를 포함한 Java 개발 패키지.
   - 주요 구성: javac, java, javadoc 등.
2. **JRE (Java Runtime Environment)**: Java 실행 환경.
   - 주요 구성: JVM, 라이브러리, 실행 환경.

### 3-1. JDK와 JRE의 차이
| 기능           | JDK              | JRE          |
|----------------|------------------|--------------|
| 실행 환경 포함 | O                | O            |
| 컴파일러 포함 | O                | X            |

## 4. 주요 Java 버전의 변화
- ### **Java 8**:
   - 람다 표현식 도입.
   - Stream API 추가.
   - `Optional` 클래스 추가.
- ### **Java 11**:
   - LTS(장기 지원) 제공.
   - `var`를 통한 지역 변수 타입 추론.
   - HTTP 클라이언트 API 추가.
- ### **Java 17**:
   - 최신 LTS.
   - `sealed` 클래스 도입.
   - `switch`의 패턴 매칭.

## 5. 동일성과 동등성
- **동일성(==)**: 두 객체의 참조 주소를 비교하여 동일한 객체를 참조하는지 확인.
- **동등성(equals)**: 두 객체의 값이나 의미적으로 동일한지 확인하기 위해 equals() 메서드를 재정의하여 사용.

## 6. hashCode와 equals 관계
- **equals**가 true인 두 객체는 동일한 **hashCode** 값을 가져야 함.
- hashCode와 equals를 함께 재정의해야 객체를 올바르게 비교 가능.
- HashMap, HashSet 등 컬렉션에서 활용.

## 7. 직렬화와 transient 키워드
- 직렬화: 객체를 저장하거나 네트워크로 전송하기 위해 바이트 스트림으로 변환.
  - `Serializable` 인터페이스 사용.
- `transient`: 직렬화 시 제외할 필드에 사용.

## 8. 객체지향 프로그래밍의 4대 특징

### 1. 캡슐화 (Encapsulation)
- 객체 내부의 데이터를 숨기고, 외부에서 접근할 수 있는 제한된 방법 제공.
- 구현 방법
  - 접근 제어자(`private`, `protected`, `public`)를 사용하여 데이터 접근을 제한.
  - `getter`와 `setter` 메서드를 통해 필요한 데이터만 외부에 노출.

### 2. 상속 (Inheritance)
- 부모 클래스의 속성과 메서드를 자식 클래스가 물려받아 재사용.
- 구현 방법: `extends` 키워드를 사용.

### 3. 다형성 (Polymorphism)
- 동일한 메서드가 상황에 따라 다른 동작을 할 수 있도록 지원.
- 구현 방법
   - 오버로딩 (Overloading): 같은 이름의 메서드를 매개변수로 구분.
   - 오버라이딩 (Overriding): 부모 클래스의 메서드를 재정의.

### 4. 추상화 (Abstraction)
- 객체의 필수적인 부분만 노출하고, 불필요한 구현 세부 사항은 숨김.
- 구현 방법
   - 추상 클래스(`abstract` 키워드)와 추상 메서드.
   - 인터페이스(`interface`)를 통한 다중 구현.

## 9. 추상 클래스와 인터페이스의 차이
- **추상 클래스**: 상속 관계에서 사용되며, 일부 메서드는 구현을 가질 수 있음.
- **인터페이스**: 다중 구현을 위해 사용되며, 모든 메서드는 기본적으로 추상적임.
  
  | **특징**                | **추상 클래스**       | **인터페이스**       |
  |-------------------------|----------------------|----------------------|
  | **다중 상속 가능 여부**  | 불가능                | 가능                 |
  | **접근 제어자**          | 모든 접근 제어자 지원 | 기본적으로 `public`  |
  | **필드 정의**            | 인스턴스 변수 정의 가능| 상수만 정의 가능      |
  | **용도**                | 공통 기능 상속        | 다중 구현 및 기능 정의 |

## 10. 조합과 상속

### 1. 조합의 장단점
  - 조합의 장점
    - 유연성
      - 클래스 간 느슨한 결합 유지.
      - 필요한 기능을 객체를 통해 동적으로 구성 가능.
    - 재사용성 증가
      - 필요한 객체만 활용 가능.
      - 불필요한 동작이 포함되지 않음.
    - 다중 기능 구현 가능
      - 조합을 통해 여러 객체를 포함할 수 있어, 다중 상속처럼 다양한 동작 구현 가능.
    
  - 조합의 단점
    - 구현 복잡성 증가
      - 상속에 비해 객체 관 관계를 명시적으로 정의해야해 코드가 길어짐.
      - 올바르게 설계하지 않으면 코드의 가독성이 떨어짐.
    - 메모리 사용 증가
      - 객체를 참조하는 방식으로, 상속보다 메모리 사용량이 늘어날 가능성 있음.

### 2. 상속 vs 조합:  선택 기준
  - 상속 사용
    - "is-a" 관계가 명확할 때 사용.
  - 조합 사용
    - "has-a" 관계가 적합할 때 사용.

## 11. `final` 키워드
### 1. 변수
- 한 번 초기화된 값은 변경이 불가능.
- 상수 값을 정의할 때 주로 사용, 관례적으로 `static`과 함께 사용, 대문자 이름 작성

### 2. 메서드
- 메서드의 오버라이딩 금지를 위해 사용.
- 부모 클래스에서 핵심 동작을 보장하기 위해 사용.

### 3. 클래스
- 상속이 불가능한 클래스를 만들 때 사용.
- 보안 및 데이터 무결성을 보장해야 하는 경우 유용.

## 12. `static` 키워드
### 1. 변수
- 클래스 전체에서 공유되는 변수.
- 모든 객체가 동일한 값을 참조.

### 2. 메서드
- 객체 없이 호출 가능, 인스턴스 멤버에 접근 불가.
- 유틸리티 클래스에서 자주 사용됨.

### 3. 블록
- 클래스가 로드될 때 단 한 번 실행되며, 주로 `static`변수 초기화에 사용.

## 13. 초기화 순서
- `static 블록` -> `instance 블록` -> `생성자`